var documenterSearchIndex = {"docs":
[{"location":"trace/#Linearized-traces","page":"Linearized traces","title":"Linearized traces","text":"","category":"section"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"Usually, programs are executed as a sequence of nested function calls, e.g.:","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"foo(x) = 2x\nbar(x, y) = foo(x) + 3y\nbaz(x, y) = bar(x, y) - 1\n\nbaz(1.0, 2.0)","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"Sometimes, however, it's more convenient to work with a linearized representation of the computation. Example use cases include collecting computational graphs for automatic differentiation, exporting to ONNX, serialization of functions to library-independent format, etc.Â trace() lets you obtain such a linearized representation:","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"foo(x) = 2x                # hide\nbar(x, y) = foo(x) + 3y    # hide\nbaz(x, y) = bar(x, y) - 1  # hide\n\nusing Ghost\n\nval, tape = trace(baz, 1.0, 2.0)","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"trace() returns two values - the result of the original function call and the generated tape. The structure of the tape is described in Tape anatomy section, here just note that trace() recursed into baz(), bar() and foo(), but recorded +, - and * onto the tape as is. This is because +, - and * are considered \"primitives\", i.e. the most basic operations which all other functions consist of. This behavior can be customized using one of the two keyword arguments:","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"primitives - an iterable of functions to be considered primitive\nis_primitive(sig) - a function which takes a method call signature and returns true if this method must be considered primitive and false otherwise","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"Here's an example:","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"foo(x) = 2x                # hide\nbar(x, y) = foo(x) + 3y    # hide\nbaz(x, y) = bar(x, y) - 1  # hide\n\nusing Ghost                # hide\n\nval, tape = trace(baz, 1.0, 2.0; primitives=Set([+, -, *, foo]))","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"The default behavior is defined by Ghost.is_primitive function and can be extended e.g. like this:","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"foo(x) = 2x                # hide\nbar(x, y) = foo(x) + 3y    # hide\nbaz(x, y) = bar(x, y) - 1  # hide\n\nusing Ghost                # hide\n\n\nfunction custom_is_primitive(sig)\n    return Ghost.is_primitive(sig) || sig == Tuple{typeof(foo), Float64}\nend\n\nval, tape = trace(baz, 1.0, 2.0; is_primitive=custom_is_primitive)","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"An easy way to get a valid call signature is to use Ghost.call_signature.","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"See also Ghost.FunctionResolver for better understanding of the implementation of is_primitive.","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"In complex scenarios it may be useful to bring additional application-specific data together with a tape. For this purpose Tape is parametrized by a context type which is Dict{Any, Any} by default, but can be anything. A context object can be attached during tracing using the ctx keyword:","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"foo(x) = 2x                # hide\nbar(x, y) = foo(x) + 3y    # hide\nbaz(x, y) = bar(x, y) - 1  # hide\n\nusing Ghost                # hide\n\nmutable struct MyCtx\n    a\n    b\nend\n\nval, tape = trace(baz, 1.0, 2.0; ctx=MyCtx(0, 0))","category":"page"},{"location":"trace/","page":"Linearized traces","title":"Linearized traces","text":"The presense of the context doesn't affect tracing, but can be used during further tape processing. See Tape context for more details.","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"CurrentModule = Ghost","category":"page"},{"location":"loops/#Loops","page":"Loops","title":"Loops","text":"","category":"section"},{"location":"loops/","page":"Loops","title":"Loops","text":"By default, Ghost records all function calls as they are executed. If a particular function is executed several times inside of a loop, Ghost will record each execution separately:","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"using Ghost\n\n\nfunction loop1(x, n)\n    while n > 0\n        x = 2x\n        n = n - 1\n    end\n    return x\nend\n\n_, tape1 = trace(loop1, 2.0, 3)","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"Ghost also has experimental support for tracing loops as a special Loop operation which can be turned on using should_trace_loops!(true)","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"using Ghost\nimport Ghost: should_trace_loops!\n\nshould_trace_loops!(true)\n\nfunction loop1(x, n)\n    while n > 0\n        x = 2x\n        n = n - 1\n    end\n    return x\nend\n\n_, tape2 = trace(loop1, 2.0, 3)","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"Unlike fully static tape which always executes as many iterations as there were during the tracing, tape with loops follows the control flow of the original function:","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"play!(tape1, loop1, 2.0, 3)  # ==> 16.0\nplay!(tape1, loop1, 2.0, 4)  # ==> 16.0\nplay!(tape1, loop1, 2.0, 5)  # ==> 16.0\n\nplay!(tape2, loop1, 2.0, 3)  # ==> 16.0\nplay!(tape2, loop1, 2.0, 4)  # ==> 32.0\nplay!(tape2, loop1, 2.0, 5)  # ==> 64.0","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"Note that Loop itself contains a subtape and is quite independent from the outer tape.","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"tape2[V(4)].subtape","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"Tape{Dict{Any, Any}}\n  inp %1::Int64\n  inp %2::Float64\n  %3 = >(%1, 0)::Bool\n  %4 = *(2, %2)::Float64\n  %5 = -(%1, 1)::Int64","category":"page"},{"location":"loops/","page":"Loops","title":"Loops","text":"warning: Warning\nTo work correctly, Loop expects at least one full iteration during both - tracing and execution.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Ghost","category":"page"},{"location":"reference/#Public-API","page":"Reference","title":"Public API","text":"","category":"section"},{"location":"reference/#Tracing","page":"Reference","title":"Tracing","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"trace\nis_primitive\ncall_signature\n__new__","category":"page"},{"location":"reference/#Ghost.trace","page":"Reference","title":"Ghost.trace","text":"trace(f, args...; is_primitive, primitives)\n\nTrace function call, produce call value and a Tape.\n\ntrace records to the tape primitive methods and recursively dives into non-primitives. There are 2 ways to tell trace that a particular method is a primitive:\n\nprovide is_primitive(sig) -> Bool function, where sig is   is a method signature, e.g. Tuple{map(typeof, (f, args...))...}\nprovide an iterable primitives; in this case trace matches   all methods of this function\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.is_primitive","page":"Reference","title":"Ghost.is_primitive","text":"is_primitive(sig)\n\nThe default implementation of is_primitive argument in trace(). Returns true if the method with the provided signature is defined in one of the Julia's built-in modules, e.g. Base, Core, Broadcast, etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.call_signature","page":"Reference","title":"Ghost.call_signature","text":"call_signature(fn, args...)\ncall_signature(tape::Tape, op::Call)\n\nGet a signature of a function call. The obtain signature is suitable for is_primitive(sig).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.__new__","page":"Reference","title":"Ghost.__new__","text":"__new__(T, args...)\n\nUser-level version of the new() pseudofunction. Can be used to construct most Julia types, including structs without default constructors, closures, etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Variables","page":"Reference","title":"Variables","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Variable\nbound\nrebind!\nrebind_context!","category":"page"},{"location":"reference/#Ghost.Variable","page":"Reference","title":"Ghost.Variable","text":"Variable represents a reference to an operation on a tape. Variables can be used to index tape or keep reference to a specific operation on the tape.\n\nVariables (also aliesed as V) can be:\n\nfree, created as V(id) - used for indexing into tape\nbound, created as V(op)` - used to keep a robust reference to an operation on the tape\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.bound","page":"Reference","title":"Ghost.bound","text":"Returned version of the var bound to the tape op\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.rebind!","page":"Reference","title":"Ghost.rebind!","text":"rebind!(tape::Tape, op, st::Dict)\nrebind!(tape::Tape, st::Dict; from, to)\n\nRebind all variables according to substitution table. Example:\n\ntape = Tape()\nv1, v2 = inputs!(tape, nothing, 3.0, 5.0)\nv3 = push!(tape, mkcall(*, v1, 2))\nst = Dict(v1.id => v2.id)\nrebind!(tape, st)\n@assert tape[v3].args[1].id == v2.id\n\nSee also: rebind_context!()\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.rebind_context!","page":"Reference","title":"Ghost.rebind_context!","text":"rebind_context!(tape::Tape, st::Dict)\n\nRebind variables in the tape's context according to substitution table. By default does nothing, but can be overwitten for specific Tape{C}\n\n\n\n\n\n","category":"function"},{"location":"reference/#Tape-structure","page":"Reference","title":"Tape structure","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Tape\nAbstractOp\nInput\nConstant\nCall\nLoop\ninputs\ninputs!\nmkcall","category":"page"},{"location":"reference/#Ghost.Tape","page":"Reference","title":"Ghost.Tape","text":"Linearized representation of a function execution.\n\nFields\n\nops - vector of operations on the tape\nresult - variable pointing to the operation to be used as the result\nparent - parent tape if any\nmeta - internal metadata\nc - application-specific context\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.AbstractOp","page":"Reference","title":"Ghost.AbstractOp","text":"Base type for operations on a tape\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.Input","page":"Reference","title":"Ghost.Input","text":"Operation representing input data of a tape\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.Constant","page":"Reference","title":"Ghost.Constant","text":"Operation representing a constant value on a tape\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.Call","page":"Reference","title":"Ghost.Call","text":"Operation represening function call on tape. Typically, calls are constructed using mkcall function.\n\nImportant fields of a Call{T}:\n\nfn::T - function or object to be called\nargs::Vector - vector of variables or values used as arguments\nval::Any - the result of the function call\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.Loop","page":"Reference","title":"Ghost.Loop","text":"Operation representing a loop in an computational graph. See the online documentation for details.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.inputs","page":"Reference","title":"Ghost.inputs","text":"Get list of a tape input variables\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.inputs!","page":"Reference","title":"Ghost.inputs!","text":"Set values of a tape inputs\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.mkcall","page":"Reference","title":"Ghost.mkcall","text":"mkcall(fn, args...; val=missing)\n\nConvenient constructor for Call operation. If val is missing (default) and call value can be calculated from (bound) variables and constants, they are calculated. To prevent this behavior, set val to some neutral value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Tape-transformations","page":"Reference","title":"Tape transformations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"push!\ninsert!\nreplace!\ndeleteat!\nprimitivize!","category":"page"},{"location":"reference/#Base.push!","page":"Reference","title":"Base.push!","text":"push!(tape::Tape, op::AbstractOp)\n\nPush a new operation to the end of the tape.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.insert!","page":"Reference","title":"Base.insert!","text":"insert!(tape::Tape, idx::Integer, ops::AbstractOp...)\n\nInsert new operations into tape starting from position idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.replace!","page":"Reference","title":"Base.replace!","text":"replace!(tape, op  => new_ops; rebind_to=length(new_ops), old_new=Dict())\n\nReplace specified operation with 1 or more other operations, rebind variables in the reminder of the tape to ops[rebind_to].\n\nOperation can be specified directly, by a variable or by ID.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.deleteat!","page":"Reference","title":"Base.deleteat!","text":"deleteat!(tape::Tape, idx; rebind_to = nothing)\n\nRemove tape[V(idx)] from the tape. If rebind_to is not nothing, then replace all references to V(idx) with V(rebind_to).\n\nidx may be an index or Variable/AbstractOp directly.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.primitivize!","page":"Reference","title":"Ghost.primitivize!","text":"primitivize!(tape::Tape; is_primitive=is_primitive)\n\nTrace non-primitive function calls on a tape and decompose them into a list of corresponding primitive calls.\n\nExample\n\nf(x) = 2x - 1\ng(x) = f(x) + 5\n\ntape = Tape()\n_, x = inputs!(tape, g, 3.0)\ny = push!(tape, mkcall(f, x))\nz = push!(tape, mkcall(+, y, 5))\ntape.result = z\n\nprimitivize!(tape)\n\n# output\n\nTape{Dict{Any, Any}}\n  inp %1::typeof(g)\n  inp %2::Float64\n  %3 = *(2, %2)::Float64\n  %4 = -(%3, 1)::Float64\n  %5 = +(%4, 5)::Float64\n\n\n\n\n\n","category":"function"},{"location":"reference/#Tape-execution","page":"Reference","title":"Tape execution","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"play!\ncompile\nto_expr","category":"page"},{"location":"reference/#Ghost.play!","page":"Reference","title":"Ghost.play!","text":"play!(tape::Tape, args...; debug=false)\n\nExecute operations on the tape one by one. If debug=true, print each operation before execution.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.compile","page":"Reference","title":"Ghost.compile","text":"compile(tape::Tape)\n\nCompile tape into a normal Julia function.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.to_expr","page":"Reference","title":"Ghost.to_expr","text":"to_expr(tape::Tape)\n\nGenerate a Julia expression corresponding to the tape.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Loops","page":"Reference","title":"Loops","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"should_trace_loops!\nshould_trace_loops","category":"page"},{"location":"reference/#Ghost.should_trace_loops!","page":"Reference","title":"Ghost.should_trace_loops!","text":"should_trace_loops!(val=false)\n\nTurn on/off loop tracing. Without parameters, resets the flag to the default value\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.should_trace_loops","page":"Reference","title":"Ghost.should_trace_loops","text":"should_trace_loops()\n\nCheck the current value of the loop tracing option.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Internal-API","page":"Reference","title":"Internal API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following types and functions might be useful for better understanding of Ghost behavior, but are not part of the public API and may not hold backward compatibility guarantees.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"FunctionResolver\nFrame\nTracerOptions\n_LoopEnd\nrecord_or_recurse!\npush_frame!\npop_frame!\nenter_loop!\nstop_loop_tracing!\nexit_loop!","category":"page"},{"location":"reference/#Ghost.FunctionResolver","page":"Reference","title":"Ghost.FunctionResolver","text":"Dict-like data structure which maps function signature to a value. Unlike real dict, getindex(rsv, sig) returns either exact match, or closest matching function signature. Example:\n\nrsv = FunctionResolver{Symbol}()\nrsv[Tuple{typeof(sin), Float64}] = :Float64\nrsv[Tuple{typeof(sin), Real}] = :Real\nrsv[Tuple{typeof(sin), Number}] = :Number\n\nrsv[Tuple{typeof(sin), Float64}]   # ==> :Float64\nrsv[Tuple{typeof(sin), Float32}]   # ==> :Real\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.Frame","page":"Reference","title":"Ghost.Frame","text":"Frame of a call stack\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.TracerOptions","page":"Reference","title":"Ghost.TracerOptions","text":"Tracer options. Configured globally via the following methods:\n\nshouldtraceloops!()\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost._LoopEnd","page":"Reference","title":"Ghost._LoopEnd","text":"Pseudo op to designate loop end. Removed after Loop op is created\n\n\n\n\n\n","category":"type"},{"location":"reference/#Ghost.record_or_recurse!","page":"Reference","title":"Ghost.record_or_recurse!","text":"Record function call onto a tape or recurse into it.\n\nParams:\n\nt::IRTracer - current tracer\nres_id::Int - IR ID of the operation\nfarg_irvars - IR variables of the operation\nfargs - values of the operation\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.push_frame!","page":"Reference","title":"Ghost.push_frame!","text":"Push a new call frame to tracer, setting function params accordingly\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.pop_frame!","page":"Reference","title":"Ghost.pop_frame!","text":"Pop call frame from tracer\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.enter_loop!","page":"Reference","title":"Ghost.enter_loop!","text":"Trigger loop start operations.\n\nArguments:\n\nt :: IRTracer  Current tracer\nloop_id :: Int  Unique ID of a loop being entered\nloopinputir_ids :: Vector{Int}  IR IDs of variables which will be used as loop inputs. Includes  loop block inputs and any outside IDs\n\nThis function is added to the very beginning of the loop block(s). During the first iteration we initialize a subtape which will be used later to create the Loop operation on the parent tape. Since all iterations of the loop produce identical operations, we only need to trace it once. However, it turns out to be easier to record all iterations (seprated by a special _LoopEnd op) and then prune unused iterations.\n\nAnother important detail is that Loop's subtape is a completely valid and independent tape with its own call frame and inputs which include all explicit and implicit inputs to the loop's block in the original IR.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.stop_loop_tracing!","page":"Reference","title":"Ghost.stop_loop_tracing!","text":"Set flags designating the end of the first run of the loop.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ghost.exit_loop!","page":"Reference","title":"Ghost.exit_loop!","text":"Trigget loop end operations.\n\nThis function is added just before the end of the loop block. Since we record all iterations of the loop, we must remember tape IDs of continuation condition and exit variables during the first run.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"#Ghost.jl","page":"Main","title":"Ghost.jl","text":"","category":"section"},{"location":"","page":"Main","title":"Main","text":"Ghost.jl is a code tracer for the Julia programming language. It lets you trace the function execution, recording all primitive operations onto a linearized tape. Here's a quick example:","category":"page"},{"location":"","page":"Main","title":"Main","text":"using Ghost     # hide\ninc(x) = x + 1\nmul(x, y) = x * y\ninc_double(x) = mul(inc(x), inc(x))\n\nval, tape = trace(inc_double, 2.0)","category":"page"},{"location":"","page":"Main","title":"Main","text":"The tape can then be analyzed, modified and even compiled back to a normal function. See the following sections for details.","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"CurrentModule = Ghost","category":"page"},{"location":"tape/#Tape-anatomy","page":"Tape anatomy","title":"Tape anatomy","text":"","category":"section"},{"location":"tape/#Operations","page":"Tape anatomy","title":"Operations","text":"","category":"section"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"The very core of every tape is a list of operations. Let's take a look at one particular tape:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost\n\nfoo(x) = 2x + 1\n_, tape = trace(foo, 2.0)\nprint(tape)","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Each indented line in this output represents an operation. The first 2 designate the tape inputs and have type Input. Note that the traced function itself is also recorded as an input and can be referenced from other operations on the tape, which is a typical case in closures and other callable objects. We can set new inputs to the tape as inputs!(tape, foo, 3.0).","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Operations 3 and 4 represent function calls and have type Call. For example, the notation %4 = +(%3, 1) means that variable %4 is equal to the addition of variable %3 and a constant 1 (we will talk about variables in a minute). The easiest way to construct this operation is by using mkcall.","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Although constants can be used directly inside Calls, sometimes we need them as separate objects on the tape. Constant operation serves exactly this role.","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Finally, there's an experimental Loop operation which presents whole loops in a computational graphs and contain their own subtapes.","category":"page"},{"location":"tape/#Variables","page":"Tape anatomy","title":"Variables","text":"","category":"section"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Variable (also aliased as just V) is a reference to  an operation on tape. Variables can be bound or unbound.","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Unbound variables are constructed as V(id) and point to an operation by its position on a tape. Their primary use is for indexing and short-living handling, e.g.:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost                 # hide\nimport Ghost.V\nfoo(x) = 2x + 1             # hide\n_, tape = trace(foo, 2.0)   # hide\n\nop = tape[V(4)]","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"On the contrary, bound variables (created as V(op)) point to a specific operation on the tape. Even if the tape is modified, the reference is preserved. Here's an illustrative example:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost                 # hide\nimport Ghost: V, Constant   # hide\nfoo(x) = 2x + 1             # hide\n_, tape = trace(foo, 2.0)   # hide\n\nvu = V(4)         # unbound\nvb = V(tape[vu])  # bound, can also be created as `bound(tape, vu)`\n\n# insert a dummy operation\ninsert!(tape, 3, Constant(42))\nprintln(tape)\nprintln(\"Unbound variable is still $vu\")\nprintln(\"Bound variable is now $vb\")","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Most functions in Ghost create bound variables to make them resistant to transformations. Note, for example, how in the tape above the last operation automatically updated itself from +(%3, 1) to +(%4, 1). Yet sometimes explicit rebinding is neccessary, in which case rebind! can be used. Note that for rebind! to work properly with a user-defined tape context (see below), one must also implement rebind_context!","category":"page"},{"location":"tape/#Transformations","page":"Tape anatomy","title":"Transformations","text":"","category":"section"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Tapes can be modified in a variaty of ways. For this set of examples, we won't trace any function, but instead construct a tape manually:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost\nimport Ghost: Tape, V, inputs!, mkcall\n\ntape = Tape()\n# record inputs, using nothing instead of a function argument\nv1, v2, v3 = inputs!(tape, nothing, 1.0, 2.0)","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"push! is the standard way to add new operations to the tape, e.g.:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost                             # hide\nimport Ghost: Tape, V, inputs!, mkcall  # hide\ntape = Tape()                           # hide\nv1, v2, v3 = inputs!(tape, nothing, 1.0, 2.0)  # hide\n\nv4 = push!(tape, mkcall(*, v2, v3))\nprintln(tape)","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"insert! is similar to push!, but adds operation to the specified position:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost                             # hide\nimport Ghost: Tape, V, inputs!, mkcall  # hide\ntape = Tape()                           # hide\nv1, v2, v3 = inputs!(tape, nothing, 1.0, 2.0)  # hide\nv4 = push!(tape, mkcall(*, v2, v3))     # hide\n\nv5 = insert!(tape, 4, mkcall(-, v2, 1))  # inserted before v4\nprintln(tape)","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"replace! is useful when you need to replace an operation with one or more other operations.","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost                             # hide\nimport Ghost: Tape, V, inputs!, mkcall  # hide\ntape = Tape()                           # hide\nv1, v2, v3 = inputs!(tape, nothing, 1.0, 2.0)  # hide\nv4 = push!(tape, mkcall(*, v2, v3))      # hide\nv5 = insert!(tape, 4, mkcall(-, v2, 1))  # hide\n\nnew_op1 = mkcall(/, V(2), 2)\nnew_op2 = mkcall(+, V(new_op1), 1)\nreplace!(tape, 4 => [new_op1, new_op2]; rebind_to=2)\nprintln(tape)","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"deleteat! is used to remove entries from the tape.","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost                             # hide\nimport Ghost: Tape, V, inputs!, mkcall  # hide\ntape = Tape()                           # hide\n_, v1, v2 = inputs!(tape, nothing, 3.0, 5.0) # hide\nv3 = push!(tape, mkcall(*, v1, 2))      # hide\nv4 = push!(tape, mkcall(+, v3, v1))     # hide\nv5 = push!(tape, mkcall(+, v4, v2))     # hide\nv6 = push!(tape, mkcall(+, v4, v1))     # hide\n\ndeleteat!(tape, 5; rebind_to = 1)\nprintln(tape)","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Although trace creates a tape consisting only of primitives, tape itself can hold any function calls. It's possible to decompose all non-primitive calls on the tape to lists of corresponding primitives using primitivize!.","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost                             # hide\nimport Ghost: Tape, V, inputs!, mkcall  # hide\nimport Ghost: primitivize!\n\nf(x) = 2x - 1\ng(x) = f(x) + 5\n\ntape = Tape()\n_, x = inputs!(tape, g, 3.0)\ny = push!(tape, mkcall(f, x))\nz = push!(tape, mkcall(+, y, 5))\ntape.result = z\n\nprimitivize!(tape)","category":"page"},{"location":"tape/#Tape-execution-and-compilation","page":"Tape anatomy","title":"Tape execution & compilation","text":"","category":"section"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"There are 2 ways to execute a tape. For debug purposes it's easiest to run play!:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost\nimport Ghost: play!\n\nfoo(x) = 2x + 1\n_, tape = trace(foo, 2.0)\n\nplay!(tape, foo, 3.0)","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"compile turns the tape into a normal Julia function (subject to the World Age restriction):","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost\nimport Ghost: compile\n\nfoo(x) = 2x + 1\n_, tape = trace(foo, 2.0)\n\nfoo2 = compile(tape)\nfoo2(foo, 3.0)   # note: providing the original `foo` as the 1st argument","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"It's possible to see what exactly is being compiled using to_expr function.","category":"page"},{"location":"tape/#Tape-context","page":"Tape anatomy","title":"Tape context","text":"","category":"section"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Tape is parametrized by a context type. Context is a way to pass arbitrary data with a tape. For instance, imagine that you are working on a DSL engine which traces function execution and enriches the resulting tape with domain-specific operations. You also want to keep track of all added operations, but don't want to pass around an additional object holding them. You can attach a custom context to the tape and reference it as tape.c:","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"using Ghost\nimport Ghost: Variable\n\ndsl_function(x) = ...\n\n\nmutable struct DSLContext\n    added_variables::Vector{Variable}\nend\n\n_, tape = trace(dsl_function, 2.0; ctx=DSLContext([]))\n\n\nfunction add_operations(tape::Tape{DSLContext})\n    v = push!(tape, ...)\n    push!(tape.c.added_variables, v)\n    ...\nend\n\nfunction process_dsl_tape(tape::Tape{DSLContext})\n    vars = tape.c.added_variables\n    ...\nend","category":"page"},{"location":"tape/","page":"Tape anatomy","title":"Tape anatomy","text":"Just to remind you, if your context contains variables and you plan to use rebind!, you must also implement rebind_context! for your specific context type.","category":"page"}]
}
